{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-83dffb88dbc6885e76c230b704b130139ff25442",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ShieldBrain.sol": "project/contracts/ShieldBrain.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/IReactive.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Standard Reactive Network interfaces and constants\n\nuint256 constant REACTIVE_IGNORE = 0xa65f96fc951c35ead38878e0f0b7a3c744a6f5ccc1476b313353ce31712313ad;\n\ninterface IPayer {\n    function pay() external payable;\n}\n\ninterface IReactive is IPayer {\n    /**\n     * @notice Event log structure from origin chain\n     * @dev 12-field LogRecord as per Reactive Network specification\n     */\n    struct LogRecord {\n        uint256 chain_id;\n        address _contract;\n        uint256 topic_0;\n        uint256 topic_1;\n        uint256 topic_2;\n        uint256 topic_3;\n        bytes data;\n        uint256 block_number;\n        uint256 op_code;\n        uint256 block_hash;\n        uint256 tx_hash;\n        uint256 log_index;\n    }\n\n    /**\n     * @notice Callback event to trigger cross-chain execution\n     * @param chain_id Destination chain ID\n     * @param _contract Target contract address\n     * @param gas_limit Gas limit for execution\n     * @param payload Encoded function call\n     */\n    event Callback(\n        uint256 indexed chain_id,\n        address indexed _contract,\n        uint64 indexed gas_limit,\n        bytes payload\n    );\n\n    /**\n     * @notice Main reactive function triggered by subscribed events\n     * @param log Event log data from origin chain\n     */\n    function react(LogRecord calldata log) external;\n}\n\ninterface ISystemContract {\n    /**\n     * @notice Subscribe to events on origin chain\n     * @param chain_id Origin chain ID\n     * @param contract_address Contract to monitor\n     * @param topic_0 Event signature\n     * @param topic_1 First indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_2 Second indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_3 Third indexed parameter (or REACTIVE_IGNORE)\n     */\n    function subscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n\n    /**\n     * @notice Unsubscribe from events\n     */\n    function unsubscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n}\n\n"
      },
      "project/contracts/ShieldBrain.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IReactive.sol\";\n\n/**\n * @title ShieldBrain\n * @notice Reactive Network Logic Controller for ReactiveMorphoShield\n * @dev Deployed on Reactive Network (Chain ID: 5318007)\n * \n * Monitors two event sources:\n * 1. ReactiveMorphoShield.Deposit → Triggers executeLoop to build leverage\n * 2. ReactiveMorphoShield.LoopStep → Continues looping or stops\n * 3. MockOracle.PriceUpdated → Triggers unwind if price crashes\n * \n * Logic:\n * - On Deposit: Start looping (send executeLoop callback)\n * - On LoopStep: Check if max iterations reached, if not continue looping\n * - On PriceUpdated: Check if price below crash threshold, trigger emergency unwind\n */\ncontract ShieldBrain is IReactive {\n    // ============ Immutable Configuration ============\n    \n    address public immutable vaultContract;      // ReactiveMorphoShield address on Sepolia\n    address public immutable oracleContract;     // MockOracle address on Sepolia\n    address public immutable systemContract;     // Reactive System Contract\n    \n    // ============ Constants ============\n    \n    // Chain IDs\n    uint256 public constant ORIGIN_CHAIN_ID = 11155111; // Ethereum Sepolia\n    uint256 public constant DEST_CHAIN_ID = 11155111;   // Same chain (Sepolia)\n    \n    // Event signatures (Topic 0)\n    uint256 public constant TOPIC_DEPOSIT = \n        uint256(keccak256(\"Deposit(address,uint256)\"));\n    \n    uint256 public constant TOPIC_LOOP_STEP = \n        uint256(keccak256(\"LoopStep(uint8,uint256,uint256)\"));\n    \n    uint256 public constant TOPIC_PRICE_UPDATED = \n        uint256(keccak256(\"PriceUpdated(uint256,uint256)\"));\n    \n    // Strategy parameters\n    uint8 public constant MAX_LOOP_ITERATIONS = 5;       // Max loops per deposit\n    uint256 public constant CRASH_PRICE_THRESHOLD = 2000 * 1e36; // $2000 (36 decimals)\n    \n    uint64 public constant CALLBACK_GAS_LIMIT = 1000000;  // 1M gas for Morpho operations\n    \n    // ============ Events ============\n    \n    event LoopTriggered(address indexed user, uint8 iteration);\n    event UnwindTriggered(uint256 price, uint256 timestamp);\n    event MaxIterationsReached(uint8 finalIteration);\n    \n    // ============ Constructor ============\n    \n    /**\n     * @notice Initialize ShieldBrain with subscription setup\n     * @param _vaultContract ReactiveMorphoShield address on Sepolia\n     * @param _oracleContract MockOracle address on Sepolia\n     * @param _systemContract Reactive System Contract address\n     */\n    constructor(\n        address _vaultContract,\n        address _oracleContract,\n        address _systemContract\n    ) {\n        vaultContract = _vaultContract;\n        oracleContract = _oracleContract;\n        systemContract = _systemContract;\n        \n        // Always subscribe to events (regardless of deployment method)\n        // Subscription 1: ReactiveMorphoShield Deposit events\n        ISystemContract(systemContract).subscribe(\n            ORIGIN_CHAIN_ID,\n            vaultContract,\n            TOPIC_DEPOSIT,\n            REACTIVE_IGNORE,  // Don't filter by user\n            REACTIVE_IGNORE,\n            REACTIVE_IGNORE\n        );\n        \n        // Subscription 2: ReactiveMorphoShield LoopStep events\n        ISystemContract(systemContract).subscribe(\n            ORIGIN_CHAIN_ID,\n            vaultContract,\n            TOPIC_LOOP_STEP,\n            REACTIVE_IGNORE,\n            REACTIVE_IGNORE,\n            REACTIVE_IGNORE\n        );\n        \n        // Subscription 3: MockOracle PriceUpdated events\n        ISystemContract(systemContract).subscribe(\n            ORIGIN_CHAIN_ID,\n            oracleContract,\n            TOPIC_PRICE_UPDATED,\n            REACTIVE_IGNORE,\n            REACTIVE_IGNORE,\n            REACTIVE_IGNORE\n        );\n    }\n    \n    // ============ Reactive Logic ============\n    \n    /**\n     * @notice Main reactive function - processes subscribed events\n     * @param log Event log from origin chain\n     * @dev Called automatically by Reactive Network when subscribed event detected\n     */\n    function react(LogRecord calldata log) external override {\n        // Validate origin chain\n        require(log.chain_id == ORIGIN_CHAIN_ID, \"ShieldBrain: wrong chain\");\n        \n        // Route to appropriate handler based on event signature\n        if (log.topic_0 == TOPIC_DEPOSIT) {\n            _handleDeposit(log);\n        } else if (log.topic_0 == TOPIC_LOOP_STEP) {\n            _handleLoopStep(log);\n        } else if (log.topic_0 == TOPIC_PRICE_UPDATED) {\n            _handlePriceUpdate(log);\n        } else {\n            revert(\"ShieldBrain: unknown event\");\n        }\n    }\n    \n    /**\n     * @notice Handle Deposit event - initiate first loop\n     * @param log Event log containing deposit data\n     */\n    function _handleDeposit(LogRecord calldata log) internal {\n        require(log._contract == vaultContract, \"ShieldBrain: wrong vault\");\n        \n        // Decode event: Deposit(address indexed user, uint256 amount)\n        address user = address(uint160(log.topic_1)); // First indexed param\n        // amount is in log.data but we don't need it\n        \n        // Trigger first loop iteration\n        _sendLoopCallback();\n        \n        emit LoopTriggered(user, 1);\n    }\n    \n    /**\n     * @notice Handle LoopStep event - continue or stop looping\n     * @param log Event log containing loop step data\n     */\n    function _handleLoopStep(LogRecord calldata log) internal {\n        require(log._contract == vaultContract, \"ShieldBrain: wrong vault\");\n        \n        // Decode event: LoopStep(uint8 iteration, uint256 borrowedAmount, uint256 mintedCollateral)\n        (uint8 iteration, uint256 borrowedAmount, ) = \n            abi.decode(log.data, (uint8, uint256, uint256));\n        \n        // Decision logic: Should we continue looping?\n        \n        // Stop if max iterations reached\n        if (iteration >= MAX_LOOP_ITERATIONS) {\n            emit MaxIterationsReached(iteration);\n            return;\n        }\n        \n        // Stop if borrowed amount is too small (indicates we're hitting limits)\n        if (borrowedAmount < 100 * 1e6) { // Less than 100 USDC\n            return;\n        }\n        \n        // Continue looping\n        _sendLoopCallback();\n        \n        emit LoopTriggered(address(0), iteration + 1);\n    }\n    \n    /**\n     * @notice Handle price update - check for crash\n     * @param log Event log containing price data\n     */\n    function _handlePriceUpdate(LogRecord calldata log) internal {\n        require(log._contract == oracleContract, \"ShieldBrain: wrong oracle\");\n        \n        // Decode event: PriceUpdated(uint256 newPrice, uint256 timestamp)\n        (uint256 newPrice, uint256 timestamp) = abi.decode(log.data, (uint256, uint256));\n        \n        // Emergency trigger: If price crashes below threshold\n        if (newPrice < CRASH_PRICE_THRESHOLD) {\n            _sendUnwindCallback();\n            emit UnwindTriggered(newPrice, timestamp);\n        }\n    }\n    \n    // ============ Callback Helpers ============\n    \n    /**\n     * @notice Send callback to execute one loop iteration\n     */\n    function _sendLoopCallback() internal {\n        bytes memory payload = abi.encodeWithSignature(\n            \"executeLoop(address)\",\n            address(0) // Will be replaced with RVM ID by Reactive Network\n        );\n        \n        emit Callback(\n            DEST_CHAIN_ID,\n            vaultContract,\n            CALLBACK_GAS_LIMIT,\n            payload\n        );\n    }\n    \n    /**\n     * @notice Send callback to unwind position (emergency)\n     */\n    function _sendUnwindCallback() internal {\n        bytes memory payload = abi.encodeWithSignature(\n            \"unwind(address)\",\n            address(0) // Will be replaced with RVM ID by Reactive Network\n        );\n        \n        emit Callback(\n            DEST_CHAIN_ID,\n            vaultContract,\n            CALLBACK_GAS_LIMIT,\n            payload\n        );\n    }\n    \n    // ============ Funding ============\n    \n    /**\n     * @notice Receive funding for RVM execution gas\n     */\n    function pay() external payable override {\n        // Accepts ETH/lReact for RVM transaction costs\n    }\n    \n    /**\n     * @notice Allow contract to receive ETH\n     */\n    receive() external payable {}\n}\n"
      }
    }
  }
}