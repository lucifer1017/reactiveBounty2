{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-76717d91419f8f9f28fd14dd2497817e9d8b7f62",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ReactiveMorphoShield.sol": "project/contracts/ReactiveMorphoShield.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IMorpho.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title IMorpho\r\n * @notice Interface for Morpho Blue lending protocol\r\n * @dev Morpho Blue Sepolia: 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb\r\n * \r\n * Morpho Blue is a minimal, immutable lending primitive.\r\n * Markets are defined by 5 parameters (MarketParams).\r\n */\r\ninterface IMorpho {\r\n    /**\r\n     * @notice Market parameters that define a unique lending market\r\n     * @param loanToken The loan token (asset to borrow, e.g., USDC)\r\n     * @param collateralToken The collateral token (e.g., WETH)\r\n     * @param oracle The price oracle address\r\n     * @param irm Interest Rate Model address (use address(0) for fixed rate)\r\n     * @param lltv Liquidation Loan-to-Value (e.g., 0.8e18 = 80%)\r\n     */\r\n    struct MarketParams {\r\n        address loanToken;\r\n        address collateralToken;\r\n        address oracle;\r\n        address irm;\r\n        uint256 lltv;\r\n    }\r\n\r\n    /**\r\n     * @notice Market ID (keccak256 hash of MarketParams)\r\n     */\r\n    struct Id {\r\n        bytes32 value;\r\n    }\r\n\r\n    /**\r\n     * @notice Supply collateral to a market\r\n     * @param marketParams The market parameters\r\n     * @param assets Amount of collateral to supply\r\n     * @param onBehalf Address to supply on behalf of\r\n     * @param data Additional data (use empty bytes for standard supply)\r\n     */\r\n    function supplyCollateral(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        address onBehalf,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Borrow assets from a market\r\n     * @param marketParams The market parameters\r\n     * @param assets Amount to borrow (0 if using shares)\r\n     * @param shares Shares to borrow (0 if using assets)\r\n     * @param onBehalf Address to borrow on behalf of\r\n     * @param receiver Address to receive the borrowed assets\r\n     * @return assetsOut Actual assets borrowed\r\n     * @return sharesOut Actual shares borrowed\r\n     */\r\n    function borrow(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        uint256 shares,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external returns (uint256 assetsOut, uint256 sharesOut);\r\n\r\n    /**\r\n     * @notice Repay borrowed assets\r\n     * @param marketParams The market parameters\r\n     * @param assets Amount to repay (0 if using shares)\r\n     * @param shares Shares to repay (0 if using assets)\r\n     * @param onBehalf Address to repay on behalf of\r\n     * @param data Additional data (use empty bytes)\r\n     * @return assetsRepaid Actual assets repaid\r\n     * @return sharesRepaid Actual shares repaid\r\n     */\r\n    function repay(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        uint256 shares,\r\n        address onBehalf,\r\n        bytes memory data\r\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\r\n\r\n    /**\r\n     * @notice Withdraw collateral from a market\r\n     * @param marketParams The market parameters\r\n     * @param assets Amount of collateral to withdraw\r\n     * @param onBehalf Address to withdraw on behalf of\r\n     * @param receiver Address to receive the collateral\r\n     */\r\n    function withdrawCollateral(\r\n        MarketParams memory marketParams,\r\n        uint256 assets,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Get user position in a market\r\n     * @param id Market ID (hash of MarketParams)\r\n     * @param user User address\r\n     * @return supplyShares User's supply shares\r\n     * @return borrowShares User's borrow shares\r\n     * @return collateral User's collateral amount\r\n     */\r\n    function position(bytes32 id, address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 supplyShares,\r\n            uint128 borrowShares,\r\n            uint128 collateral\r\n        );\r\n\r\n    /**\r\n     * @notice Compute market ID from parameters\r\n     * @param marketParams The market parameters\r\n     * @return Market ID (bytes32 hash)\r\n     */\r\n    function idToMarketParams(MarketParams memory marketParams)\r\n        external\r\n        pure\r\n        returns (bytes32);\r\n}\r\n\r\n/**\r\n * @title IERC20\r\n * @notice Minimal ERC20 interface for token operations\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\n"
      },
      "project/contracts/IReactive.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Standard Reactive Network interfaces and constants\n\nuint256 constant REACTIVE_IGNORE = 0xa65f96fc951c35ead38878e0f0b7a3c744a6f5ccc1476b313353ce31712313ad;\n\ninterface IPayer {\n    function pay() external payable;\n}\n\ninterface IReactive is IPayer {\n    /**\n     * @notice Event log structure from origin chain\n     * @dev 12-field LogRecord as per Reactive Network specification\n     */\n    struct LogRecord {\n        uint256 chain_id;\n        address _contract;\n        uint256 topic_0;\n        uint256 topic_1;\n        uint256 topic_2;\n        uint256 topic_3;\n        bytes data;\n        uint256 block_number;\n        uint256 op_code;\n        uint256 block_hash;\n        uint256 tx_hash;\n        uint256 log_index;\n    }\n\n    /**\n     * @notice Callback event to trigger cross-chain execution\n     * @param chain_id Destination chain ID\n     * @param _contract Target contract address\n     * @param gas_limit Gas limit for execution\n     * @param payload Encoded function call\n     */\n    event Callback(\n        uint256 indexed chain_id,\n        address indexed _contract,\n        uint64 indexed gas_limit,\n        bytes payload\n    );\n\n    /**\n     * @notice Main reactive function triggered by subscribed events\n     * @param log Event log data from origin chain\n     */\n    function react(LogRecord calldata log) external;\n}\n\ninterface ISystemContract {\n    /**\n     * @notice Subscribe to events on origin chain\n     * @param chain_id Origin chain ID\n     * @param contract_address Contract to monitor\n     * @param topic_0 Event signature\n     * @param topic_1 First indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_2 Second indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_3 Third indexed parameter (or REACTIVE_IGNORE)\n     */\n    function subscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n\n    /**\n     * @notice Unsubscribe from events\n     */\n    function unsubscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n}\n\n"
      },
      "project/contracts/ReactiveMorphoShield.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./IReactive.sol\";\r\nimport \"./interfaces/IMorpho.sol\";\r\n\r\n/**\r\n * @title ReactiveMorphoShield\r\n * @notice Automated Leverage Vault using Morpho Blue on Ethereum Sepolia\r\n * @dev Integrates with real Morpho Blue protocol using mock tokens\r\n * \r\n * Architecture:\r\n * - Protocol: Morpho Blue (0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb)\r\n * - Collateral: MockWETH (18 decimals)\r\n * - Loan: MockUSDC (6 decimals)\r\n * - Oracle: MockOracle (controllable price)\r\n * - Automation: Reactive Network\r\n * \r\n * Flow:\r\n * 1. User deposits WETH collateral\r\n * 2. Reactive Network triggers executeLoop():\r\n *    - Borrow USDC from Morpho\r\n *    - \"Swap\" USDC → WETH (mint for demo)\r\n *    - Supply WETH back to Morpho\r\n *    - Repeat until target leverage reached\r\n * 3. On price crash, Reactive Network triggers unwind():\r\n *    - \"Flash loan\" USDC (mint for demo)\r\n *    - Repay all debt\r\n *    - Withdraw all collateral\r\n */\r\ncontract ReactiveMorphoShield is IPayer {\r\n    // ============ Constants ============\r\n    \r\n    /// @notice Morpho Blue protocol address on Sepolia\r\n    address public constant MORPHO = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;\r\n    \r\n    /// @notice Reactive Network Callback Proxy on Sepolia\r\n    address public constant CALLBACK_PROXY = 0xc9f36411C9897e7F959D99ffca2a0Ba7ee0D7bDA;\r\n    \r\n    // ============ Immutable State ============\r\n    \r\n    /// @notice Market parameters for this vault\r\n    IMorpho.MarketParams public market;\r\n    \r\n    /// @notice Authorized Reactive VM ID (deployer of ShieldBrain)\r\n    address public immutable reactiveVmId;\r\n    \r\n    /// @notice Collateral token (MockWETH)\r\n    IERC20 public immutable collateralToken;\r\n    \r\n    /// @notice Loan token (MockUSDC)\r\n    IERC20 public immutable loanToken;\r\n    \r\n    // ============ Strategy Parameters ============\r\n    \r\n    /// @notice Target Loan-to-Value ratio (70%)\r\n    uint256 public constant TARGET_LTV = 70;\r\n    \r\n    /// @notice Liquidation Loan-to-Value (80% = 0.8e18)\r\n    uint256 public constant LLTV = 800000000000000000;\r\n    \r\n    /// @notice Maximum loop iterations\r\n    uint8 public constant MAX_LOOPS = 5;\r\n    \r\n    /// @notice Loop iteration counter\r\n    uint8 public loopCount;\r\n    \r\n    // ============ Events ============\r\n    \r\n    event Deposit(address indexed user, uint256 amount);\r\n    event LoopStep(uint8 iteration, uint256 borrowedAmount, uint256 mintedCollateral);\r\n    event Unwind(uint256 repaidDebt, uint256 withdrawnCollateral);\r\n    \r\n    // ============ Errors ============\r\n    \r\n    error UnauthorizedCaller();\r\n    error TransferFailed();\r\n    error MaxLoopsReached();\r\n    error InvalidAmount();\r\n    \r\n    // ============ Constructor ============\r\n    \r\n    /**\r\n     * @notice Initialize the vault\r\n     * @param _loanToken MockUSDC address\r\n     * @param _collateralToken MockWETH address\r\n     * @param _oracle MockOracle address\r\n     * @param _reactiveVmId Authorized Reactive VM ID (ShieldBrain deployer)\r\n     * \r\n     * @dev Constructs MarketParams for Morpho Blue:\r\n     * - loanToken: USDC (what we borrow)\r\n     * - collateralToken: WETH (what we supply)\r\n     * - oracle: Price feed (WETH/USDC)\r\n     * - irm: address(0) (no interest for demo simplicity)\r\n     * - lltv: 0.8e18 (80% liquidation threshold)\r\n     */\r\n    constructor(\r\n        address _loanToken,\r\n        address _collateralToken,\r\n        address _oracle,\r\n        address _reactiveVmId\r\n    ) {\r\n        loanToken = IERC20(_loanToken);\r\n        collateralToken = IERC20(_collateralToken);\r\n        reactiveVmId = _reactiveVmId;\r\n        \r\n        // Initialize Morpho market parameters\r\n        market = IMorpho.MarketParams({\r\n            loanToken: _loanToken,\r\n            collateralToken: _collateralToken,\r\n            oracle: _oracle,\r\n            irm: address(0), // No interest rate model for deterministic demo\r\n            lltv: LLTV       // 80% liquidation threshold\r\n        });\r\n    }\r\n    \r\n    // ============ User Entry Point ============\r\n    \r\n    /**\r\n     * @notice Deposit collateral to start leveraged position\r\n     * @param amount Amount of WETH to deposit (18 decimals)\r\n     * \r\n     * @dev Steps:\r\n     * 1. Transfer WETH from user\r\n     * 2. Approve Morpho to spend WETH\r\n     * 3. Supply collateral to Morpho market\r\n     * 4. Emit Deposit event → Triggers Reactive Network automation\r\n     */\r\n    function deposit(uint256 amount) external {\r\n        if (amount == 0) revert InvalidAmount();\r\n        \r\n        // Reset loop counter for new deposit\r\n        loopCount = 0;\r\n        \r\n        // Transfer WETH from user to vault\r\n        bool success = collateralToken.transferFrom(msg.sender, address(this), amount);\r\n        if (!success) revert TransferFailed();\r\n        \r\n        // Approve Morpho to spend WETH\r\n        collateralToken.approve(MORPHO, amount);\r\n        \r\n        // Supply collateral to Morpho\r\n        IMorpho(MORPHO).supplyCollateral(\r\n            market,\r\n            amount,\r\n            address(this), // Supply on behalf of this vault\r\n            \"\"            // No additional data\r\n        );\r\n        \r\n        // Emit event to trigger Reactive Network\r\n        emit Deposit(msg.sender, amount);\r\n    }\r\n    \r\n    // ============ Reactive Automation ============\r\n    \r\n    /**\r\n     * @notice Execute one leverage loop iteration\r\n     * @param sender RVM ID (injected by Reactive Network)\r\n     * \r\n     * @dev Called automatically by Reactive Network\r\n     * \r\n     * Steps:\r\n     * 1. Borrow USDC from Morpho (against WETH collateral)\r\n     * 2. \"Swap\" USDC → WETH (simplified: mint WETH for demo)\r\n     * 3. Supply new WETH as collateral\r\n     * 4. Emit LoopStep event → Triggers next iteration or stops\r\n     * \r\n     * Simplifications for Demo:\r\n     * - Fixed borrow amount (1000 USDC) instead of dynamic calculation\r\n     * - Mint WETH instead of real swap (no DEX liquidity needed)\r\n     * - No slippage checks (not relevant for minting)\r\n     */\r\n    function executeLoop(address sender) external onlyReactive(sender) {\r\n        // Check if max loops reached\r\n        if (loopCount >= MAX_LOOPS) {\r\n            revert MaxLoopsReached();\r\n        }\r\n        \r\n        loopCount++;\r\n        \r\n        // Step 1: Borrow USDC from Morpho\r\n        // Using fixed amount for demo simplicity (1000 USDC = 1000 * 1e6)\r\n        uint256 borrowAmount = 1000 * 1e6; // 1000 USDC (6 decimals)\r\n        \r\n        // Borrow USDC (receive to this vault)\r\n        IMorpho(MORPHO).borrow(\r\n            market,\r\n            borrowAmount,  // Amount of USDC to borrow\r\n            0,             // Shares (0 = use assets mode)\r\n            address(this), // Borrow on behalf of vault\r\n            address(this)  // Receive borrowed USDC\r\n        );\r\n        \r\n        // Step 2: \"Swap\" USDC → WETH\r\n        // For demo, we simply mint equivalent WETH instead of using a real DEX\r\n        // Assume price: 1 ETH = $3000, so 1000 USDC = 0.333... ETH\r\n        // 1000 USDC (6 decimals) → 0.333... WETH (18 decimals)\r\n        // Formula: wethAmount = (usdcAmount * 1e18) / 3000e6\r\n        uint256 wethAmount = (borrowAmount * 1e18) / 3000e6;\r\n        \r\n        // Mint WETH to vault (simulates swap output)\r\n        // Note: MockWETH has public mint() function\r\n        (bool mintSuccess, ) = address(collateralToken).call(\r\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), wethAmount)\r\n        );\r\n        require(mintSuccess, \"Mint failed\");\r\n        \r\n        // Step 3: Supply minted WETH back to Morpho\r\n        collateralToken.approve(MORPHO, wethAmount);\r\n        IMorpho(MORPHO).supplyCollateral(\r\n            market,\r\n            wethAmount,\r\n            address(this),\r\n            \"\"\r\n        );\r\n        \r\n        // Emit event to trigger next iteration (ShieldBrain decides)\r\n        emit LoopStep(loopCount, borrowAmount, wethAmount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency unwind: Close leveraged position\r\n     * @param sender RVM ID (injected by Reactive Network)\r\n     * \r\n     * @dev Called by Reactive Network when price crashes\r\n     * \r\n     * Steps:\r\n     * 1. \"Flash loan\" USDC (simplified: mint USDC for demo)\r\n     * 2. Repay all debt to Morpho\r\n     * 3. Withdraw all collateral from Morpho\r\n     * 4. Cleanup (in production, would repay flash loan)\r\n     * \r\n     * Simplifications for Demo:\r\n     * - Mint USDC instead of real flash loan\r\n     * - No flash loan fee\r\n     * - No repayment needed (minted tokens)\r\n     */\r\n    function unwind(address sender) external onlyReactive(sender) {\r\n        // Query current debt from Morpho\r\n        // marketId = keccak256(abi.encode(market))\r\n        bytes32 marketId = keccak256(abi.encode(market));\r\n        \r\n        (, uint128 borrowShares, uint128 collateralAmount) = IMorpho(MORPHO).position(\r\n            marketId,\r\n            address(this)\r\n        );\r\n        \r\n        // If no debt, nothing to unwind\r\n        if (borrowShares == 0) {\r\n            emit Unwind(0, collateralAmount);\r\n            return;\r\n        }\r\n        \r\n        // Step 1: \"Flash loan\" USDC to repay debt\r\n        // For demo, we mint USDC instead of using real flash loan\r\n        // Estimate debt amount: 5000 USDC should be enough for 5 loops\r\n        uint256 debtAmount = 5000 * 1e6; // 5000 USDC (6 decimals)\r\n        \r\n        // Mint USDC to vault (simulates flash loan)\r\n        (bool mintSuccess, ) = address(loanToken).call(\r\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), debtAmount)\r\n        );\r\n        require(mintSuccess, \"Mint failed\");\r\n        \r\n        // Step 2: Approve Morpho to spend USDC\r\n        loanToken.approve(MORPHO, debtAmount);\r\n        \r\n        // Step 3: Repay all debt (use type(uint256).max for full repayment)\r\n        IMorpho(MORPHO).repay(\r\n            market,\r\n            0,             // Assets (0 = use shares mode)\r\n            type(uint256).max, // Repay all shares\r\n            address(this), // Repay on behalf of vault\r\n            \"\"            // No additional data\r\n        );\r\n        \r\n        // Step 4: Withdraw all collateral\r\n        IMorpho(MORPHO).withdrawCollateral(\r\n            market,\r\n            type(uint256).max, // Withdraw all collateral\r\n            address(this),     // Withdraw on behalf of vault\r\n            address(this)      // Receive collateral\r\n        );\r\n        \r\n        // Reset loop counter\r\n        loopCount = 0;\r\n        \r\n        // Remaining WETH stays in vault (user can withdraw manually or via another function)\r\n        emit Unwind(debtAmount, collateralAmount);\r\n    }\r\n    \r\n    // ============ View Functions ============\r\n    \r\n    /**\r\n     * @notice Get current position status\r\n     * @return collateral Amount of collateral supplied\r\n     * @return debt Amount of debt (borrow shares)\r\n     * @return currentLoopCount Current loop iteration\r\n     */\r\n    function getPosition()\r\n        external\r\n        view\r\n        returns (\r\n            uint128 collateral,\r\n            uint128 debt,\r\n            uint8 currentLoopCount\r\n        )\r\n    {\r\n        bytes32 marketId = keccak256(abi.encode(market));\r\n        (, uint128 borrowShares, uint128 collateralAmount) = IMorpho(MORPHO).position(\r\n            marketId,\r\n            address(this)\r\n        );\r\n        \r\n        return (collateralAmount, borrowShares, loopCount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get market ID\r\n     * @return Market ID (bytes32 hash of MarketParams)\r\n     */\r\n    function getMarketId() external view returns (bytes32) {\r\n        return keccak256(abi.encode(market));\r\n    }\r\n    \r\n    // ============ Security ============\r\n    \r\n    /**\r\n     * @notice Modifier to ensure only Reactive Network can call\r\n     * @param sender RVM ID injected by Reactive Network\r\n     * \r\n     * @dev Two-layer security:\r\n     * 1. msg.sender must be Callback Proxy (on-chain verification)\r\n     * 2. sender must match authorized RVM ID (off-chain injection)\r\n     */\r\n    modifier onlyReactive(address sender) {\r\n        // Layer 1: Must be called by Callback Proxy\r\n        if (msg.sender != CALLBACK_PROXY) revert UnauthorizedCaller();\r\n        \r\n        // Layer 2: RVM ID must match authorized ShieldBrain deployer\r\n        if (sender != reactiveVmId) revert UnauthorizedCaller();\r\n        \r\n        _;\r\n    }\r\n    \r\n    // ============ Funding ============\r\n    \r\n    /**\r\n     * @notice Receive funding for callback gas\r\n     * @dev Required by IPayer interface\r\n     */\r\n    function pay() external payable override {\r\n        // Accepts ETH for callback execution gas\r\n    }\r\n    \r\n    /**\r\n     * @notice Allow contract to receive ETH\r\n     */\r\n    receive() external payable {}\r\n}\r\n\r\n\r\n"
      }
    }
  }
}