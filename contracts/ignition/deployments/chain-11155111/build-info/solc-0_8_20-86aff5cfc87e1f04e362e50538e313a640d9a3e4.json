{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-86aff5cfc87e1f04e362e50538e313a640d9a3e4",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/mocks/MockLendingPool.sol": "project/contracts/mocks/MockLendingPool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/mocks/MockLendingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title MockLendingPool\r\n * @notice Simplified lending protocol for hackathon demo\r\n * @dev Implements supply/borrow/repay/withdraw with LTV checks\r\n * \r\n * Features:\r\n * - Multi-user collateral tracking\r\n * - Multi-user debt tracking\r\n * - Price oracle integration\r\n * - LTV validation (80% max)\r\n * - Health factor calculations\r\n * \r\n * Simplified vs Real Aave/Morpho:\r\n * - No interest accrual (fixed debt)\r\n * - No liquidations (for demo simplicity)\r\n * - No reserve factors\r\n * - Simple price oracle (36 decimals)\r\n */\r\ncontract MockLendingPool {\r\n    // ============ State ============\r\n    \r\n    /// @notice User collateral balances (user => token => amount)\r\n    mapping(address => mapping(address => uint256)) public userCollateral;\r\n    \r\n    /// @notice User debt balances (user => token => amount)\r\n    mapping(address => mapping(address => uint256)) public userDebt;\r\n    \r\n    /// @notice Total liquidity per token (available to borrow)\r\n    mapping(address => uint256) public totalLiquidity;\r\n    \r\n    /// @notice Price oracle\r\n    address public immutable oracle;\r\n    \r\n    /// @notice Maximum LTV (80% = 0.8e18)\r\n    uint256 public constant MAX_LTV = 800000000000000000;\r\n    \r\n    /// @notice Minimum health factor (1.2e18 = 1.2)\r\n    uint256 public constant MIN_HEALTH_FACTOR = 1200000000000000000;\r\n    \r\n    // ============ Events ============\r\n    \r\n    event Supply(address indexed user, address indexed token, uint256 amount);\r\n    event Borrow(address indexed user, address indexed token, uint256 amount);\r\n    event Repay(address indexed user, address indexed token, uint256 amount);\r\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\r\n    event LiquidityAdded(address indexed token, uint256 amount);\r\n    \r\n    // ============ Errors ============\r\n    \r\n    error InsufficientCollateral();\r\n    error InsufficientLiquidity();\r\n    error HealthFactorTooLow();\r\n    error TransferFailed();\r\n    error InvalidAmount();\r\n    \r\n    // ============ Constructor ============\r\n    \r\n    /**\r\n     * @notice Initialize the lending pool\r\n     * @param _oracle MockOracle address for price feeds\r\n     */\r\n    constructor(address _oracle) {\r\n        oracle = _oracle;\r\n    }\r\n    \r\n    // ============ Admin Functions ============\r\n    \r\n    /**\r\n     * @notice Add liquidity to the pool (for borrowing)\r\n     * @param token Token to add liquidity for\r\n     * @param amount Amount to add\r\n     * @dev Anyone can add liquidity (for demo purposes)\r\n     */\r\n    function addLiquidity(address token, uint256 amount) external {\r\n        // Transfer tokens to pool\r\n        (bool success, ) = token.call(\r\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), amount)\r\n        );\r\n        if (!success) revert TransferFailed();\r\n        \r\n        // Increase available liquidity\r\n        totalLiquidity[token] += amount;\r\n        \r\n        emit LiquidityAdded(token, amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Seed initial liquidity by minting (for demo)\r\n     * @param token Token to seed\r\n     * @param amount Amount to mint and add\r\n     * @dev Only works with MockTokens that have public mint()\r\n     */\r\n    function seedLiquidity(address token, uint256 amount) external {\r\n        // Mint tokens to pool\r\n        (bool success, ) = token.call(\r\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), amount)\r\n        );\r\n        if (!success) revert TransferFailed();\r\n        \r\n        // Increase available liquidity\r\n        totalLiquidity[token] += amount;\r\n        \r\n        emit LiquidityAdded(token, amount);\r\n    }\r\n    \r\n    // ============ Core Lending Functions ============\r\n    \r\n    /**\r\n     * @notice Supply collateral to the pool\r\n     * @param token Collateral token (e.g., WETH)\r\n     * @param amount Amount to supply\r\n     * @param onBehalf Address to supply on behalf of (for vault pattern)\r\n     */\r\n    function supply(address token, uint256 amount, address onBehalf) external {\r\n        if (amount == 0) revert InvalidAmount();\r\n        \r\n        // Transfer tokens to pool\r\n        (bool success, ) = token.call(\r\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), amount)\r\n        );\r\n        if (!success) revert TransferFailed();\r\n        \r\n        // Increase user's collateral\r\n        userCollateral[onBehalf][token] += amount;\r\n        \r\n        emit Supply(onBehalf, token, amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Borrow tokens against collateral\r\n     * @param collateralToken Collateral token (e.g., WETH)\r\n     * @param borrowToken Token to borrow (e.g., USDC)\r\n     * @param amount Amount to borrow\r\n     * @param onBehalf Address to borrow on behalf of\r\n     * @param receiver Address to receive borrowed tokens\r\n     */\r\n    function borrow(\r\n        address collateralToken,\r\n        address borrowToken,\r\n        uint256 amount,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external {\r\n        if (amount == 0) revert InvalidAmount();\r\n        \r\n        // Check if pool has enough liquidity\r\n        if (totalLiquidity[borrowToken] < amount) revert InsufficientLiquidity();\r\n        \r\n        // Increase user's debt\r\n        userDebt[onBehalf][borrowToken] += amount;\r\n        \r\n        // Check health factor after borrow\r\n        uint256 healthFactor = calculateHealthFactor(onBehalf, collateralToken, borrowToken);\r\n        if (healthFactor < MIN_HEALTH_FACTOR) {\r\n            // Revert the debt increase\r\n            userDebt[onBehalf][borrowToken] -= amount;\r\n            revert HealthFactorTooLow();\r\n        }\r\n        \r\n        // Decrease available liquidity\r\n        totalLiquidity[borrowToken] -= amount;\r\n        \r\n        // Transfer borrowed tokens to receiver\r\n        (bool success, ) = borrowToken.call(\r\n            abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount)\r\n        );\r\n        if (!success) revert TransferFailed();\r\n        \r\n        emit Borrow(onBehalf, borrowToken, amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Repay borrowed tokens\r\n     * @param token Token to repay (e.g., USDC)\r\n     * @param amount Amount to repay (or max for full repayment)\r\n     * @param onBehalf Address to repay debt for\r\n     */\r\n    function repay(address token, uint256 amount, address onBehalf) external returns (uint256) {\r\n        uint256 userDebtAmount = userDebt[onBehalf][token];\r\n        \r\n        // If amount is max uint256, repay all debt\r\n        uint256 repayAmount = amount;\r\n        if (amount == type(uint256).max || amount > userDebtAmount) {\r\n            repayAmount = userDebtAmount;\r\n        }\r\n        \r\n        if (repayAmount == 0) return 0;\r\n        \r\n        // Transfer tokens from caller to pool\r\n        (bool success, ) = token.call(\r\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), repayAmount)\r\n        );\r\n        if (!success) revert TransferFailed();\r\n        \r\n        // Decrease user's debt\r\n        userDebt[onBehalf][token] -= repayAmount;\r\n        \r\n        // Increase available liquidity\r\n        totalLiquidity[token] += repayAmount;\r\n        \r\n        emit Repay(onBehalf, token, repayAmount);\r\n        \r\n        return repayAmount;\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw collateral from the pool\r\n     * @param token Collateral token (e.g., WETH)\r\n     * @param amount Amount to withdraw (or max for full withdrawal)\r\n     * @param onBehalf Address to withdraw collateral for\r\n     * @param receiver Address to receive withdrawn tokens\r\n     */\r\n    function withdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        uint256 userCollateralAmount = userCollateral[onBehalf][token];\r\n        \r\n        // If amount is max uint256, withdraw all\r\n        uint256 withdrawAmount = amount;\r\n        if (amount == type(uint256).max || amount > userCollateralAmount) {\r\n            withdrawAmount = userCollateralAmount;\r\n        }\r\n        \r\n        if (withdrawAmount == 0) return 0;\r\n        \r\n        // Decrease user's collateral first\r\n        userCollateral[onBehalf][token] -= withdrawAmount;\r\n        \r\n        // Check health factor after withdrawal (if user has debt)\r\n        // We need to check against all possible borrow tokens\r\n        // For simplicity, we'll allow withdrawal if debt is 0\r\n        // In production, this would check health factor properly\r\n        \r\n        // Transfer tokens to receiver\r\n        (bool success, ) = token.call(\r\n            abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, withdrawAmount)\r\n        );\r\n        if (!success) revert TransferFailed();\r\n        \r\n        emit Withdraw(onBehalf, token, withdrawAmount);\r\n        \r\n        return withdrawAmount;\r\n    }\r\n    \r\n    // ============ View Functions ============\r\n    \r\n    /**\r\n     * @notice Calculate health factor for a user\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return healthFactor Health factor (1e18 = 1.0)\r\n     */\r\n    function calculateHealthFactor(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) public view returns (uint256 healthFactor) {\r\n        uint256 collateralAmount = userCollateral[user][collateralToken];\r\n        uint256 debtAmount = userDebt[user][borrowToken];\r\n        \r\n        // If no debt, health factor is infinite\r\n        if (debtAmount == 0) {\r\n            return type(uint256).max;\r\n        }\r\n        \r\n        // Get price from oracle (36 decimals for Morpho compatibility)\r\n        (bool success, bytes memory data) = oracle.staticcall(\r\n            abi.encodeWithSignature(\"price()\")\r\n        );\r\n        require(success, \"Oracle call failed\");\r\n        uint256 price = abi.decode(data, (uint256));\r\n        \r\n        // Calculate collateral value in USD\r\n        // price is 36 decimals, collateralToken is 18 decimals, borrowToken is 6 decimals\r\n        // collateralValue = (collateralAmount * price) / 1e18 (normalize to 18 decimals)\r\n        uint256 collateralValue = (collateralAmount * price) / 1e36; // Result in collateral token decimals\r\n        \r\n        // Convert to same units as debt (USDC = 6 decimals)\r\n        // collateralValue is in 18 decimals (WETH), need to convert to 6 decimals (USDC)\r\n        collateralValue = collateralValue / 1e12; // 18 decimals -> 6 decimals\r\n        \r\n        // Health factor = (collateralValue * MAX_LTV) / debtAmount\r\n        // Scaled by 1e18 for precision\r\n        healthFactor = (collateralValue * MAX_LTV) / debtAmount;\r\n        \r\n        return healthFactor;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account data (Aave-compatible)\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return totalCollateral Total collateral (in collateral token decimals)\r\n     * @return totalDebt Total debt (in borrow token decimals)\r\n     * @return availableBorrow Available borrow capacity (in borrow token decimals)\r\n     * @return healthFactor Current health factor (1e18 = 1.0)\r\n     */\r\n    function getUserAccountData(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) external view returns (\r\n        uint256 totalCollateral,\r\n        uint256 totalDebt,\r\n        uint256 availableBorrow,\r\n        uint256 healthFactor\r\n    ) {\r\n        totalCollateral = userCollateral[user][collateralToken];\r\n        totalDebt = userDebt[user][borrowToken];\r\n        healthFactor = calculateHealthFactor(user, collateralToken, borrowToken);\r\n        \r\n        // Calculate available borrow capacity\r\n        // Get price from oracle\r\n        (bool success, bytes memory data) = oracle.staticcall(\r\n            abi.encodeWithSignature(\"price()\")\r\n        );\r\n        require(success, \"Oracle call failed\");\r\n        uint256 price = abi.decode(data, (uint256));\r\n        \r\n        // Max borrowable = (collateral value * MAX_LTV) - current debt\r\n        uint256 collateralValue = (totalCollateral * price) / 1e36; // Normalize\r\n        collateralValue = collateralValue / 1e12; // Convert to 6 decimals (USDC)\r\n        \r\n        uint256 maxBorrow = (collateralValue * MAX_LTV) / 1e18;\r\n        \r\n        if (maxBorrow > totalDebt) {\r\n            availableBorrow = maxBorrow - totalDebt;\r\n        } else {\r\n            availableBorrow = 0;\r\n        }\r\n        \r\n        return (totalCollateral, totalDebt, availableBorrow, healthFactor);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user position data\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return collateral User's collateral amount\r\n     * @return debt User's debt amount\r\n     */\r\n    function getPosition(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) external view returns (uint256 collateral, uint256 debt) {\r\n        return (userCollateral[user][collateralToken], userDebt[user][borrowToken]);\r\n    }\r\n    \r\n    /**\r\n     * @notice Allow contract to receive tokens\r\n     */\r\n    receive() external payable {}\r\n}\r\n\r\n"
      }
    }
  }
}