{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-405798bb7ee31b1d141f18f4e000995d90ac4e38",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ReactiveVault.sol": "project/contracts/ReactiveVault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/ILendingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title ILendingPool\r\n * @notice Interface for MockLendingPool\r\n */\r\ninterface ILendingPool {\r\n    /**\r\n     * @notice Supply collateral to the pool\r\n     * @param token Collateral token address\r\n     * @param amount Amount to supply\r\n     * @param onBehalf Address to supply on behalf of\r\n     */\r\n    function supply(address token, uint256 amount, address onBehalf) external;\r\n    \r\n    /**\r\n     * @notice Borrow tokens against collateral\r\n     * @param collateralToken Collateral token address\r\n     * @param borrowToken Token to borrow\r\n     * @param amount Amount to borrow\r\n     * @param onBehalf Address to borrow on behalf of\r\n     * @param receiver Address to receive borrowed tokens\r\n     */\r\n    function borrow(\r\n        address collateralToken,\r\n        address borrowToken,\r\n        uint256 amount,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external;\r\n    \r\n    /**\r\n     * @notice Repay borrowed tokens\r\n     * @param token Token to repay\r\n     * @param amount Amount to repay (use type(uint256).max for full repayment)\r\n     * @param onBehalf Address to repay debt for\r\n     * @return Amount actually repaid\r\n     */\r\n    function repay(address token, uint256 amount, address onBehalf) external returns (uint256);\r\n    \r\n    /**\r\n     * @notice Withdraw collateral from the pool\r\n     * @param token Collateral token address\r\n     * @param amount Amount to withdraw (use type(uint256).max for full withdrawal)\r\n     * @param onBehalf Address to withdraw collateral for\r\n     * @param receiver Address to receive withdrawn tokens\r\n     * @return Amount actually withdrawn\r\n     */\r\n    function withdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external returns (uint256);\r\n    \r\n    /**\r\n     * @notice Get user account data\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return totalCollateral Total collateral\r\n     * @return totalDebt Total debt\r\n     * @return availableBorrow Available borrow capacity\r\n     * @return healthFactor Current health factor\r\n     */\r\n    function getUserAccountData(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) external view returns (\r\n        uint256 totalCollateral,\r\n        uint256 totalDebt,\r\n        uint256 availableBorrow,\r\n        uint256 healthFactor\r\n    );\r\n    \r\n    /**\r\n     * @notice Get user position\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return collateral User's collateral\r\n     * @return debt User's debt\r\n     */\r\n    function getPosition(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) external view returns (uint256 collateral, uint256 debt);\r\n    \r\n    /**\r\n     * @notice Seed liquidity (mint and add to pool)\r\n     * @param token Token to seed\r\n     * @param amount Amount to seed\r\n     */\r\n    function seedLiquidity(address token, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title IERC20\r\n * @notice Minimal ERC20 interface\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n"
      },
      "project/contracts/IReactive.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Standard Reactive Network interfaces and constants\n\nuint256 constant REACTIVE_IGNORE = 0xa65f96fc951c35ead38878e0f0b7a3c744a6f5ccc1476b313353ce31712313ad;\n\ninterface IPayer {\n    function pay() external payable;\n}\n\ninterface IReactive is IPayer {\n    /**\n     * @notice Event log structure from origin chain\n     * @dev 12-field LogRecord as per Reactive Network specification\n     */\n    struct LogRecord {\n        uint256 chain_id;\n        address _contract;\n        uint256 topic_0;\n        uint256 topic_1;\n        uint256 topic_2;\n        uint256 topic_3;\n        bytes data;\n        uint256 block_number;\n        uint256 op_code;\n        uint256 block_hash;\n        uint256 tx_hash;\n        uint256 log_index;\n    }\n\n    /**\n     * @notice Callback event to trigger cross-chain execution\n     * @param chain_id Destination chain ID\n     * @param _contract Target contract address\n     * @param gas_limit Gas limit for execution\n     * @param payload Encoded function call\n     */\n    event Callback(\n        uint256 indexed chain_id,\n        address indexed _contract,\n        uint64 indexed gas_limit,\n        bytes payload\n    );\n\n    /**\n     * @notice Main reactive function triggered by subscribed events\n     * @param log Event log data from origin chain\n     */\n    function react(LogRecord calldata log) external;\n}\n\ninterface ISystemContract {\n    /**\n     * @notice Subscribe to events on origin chain\n     * @param chain_id Origin chain ID\n     * @param contract_address Contract to monitor\n     * @param topic_0 Event signature\n     * @param topic_1 First indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_2 Second indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_3 Third indexed parameter (or REACTIVE_IGNORE)\n     */\n    function subscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n\n    /**\n     * @notice Unsubscribe from events\n     */\n    function unsubscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n}\n\n"
      },
      "project/contracts/ReactiveVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./IReactive.sol\";\r\nimport \"./interfaces/ILendingPool.sol\";\r\n\r\n/**\r\n * @title ReactiveVault\r\n * @notice Automated DeFi Looping Vault using MockLendingPool\r\n * @dev Simplified architecture with mock lending protocol\r\n * \r\n * Flow:\r\n * 1. User deposits WETH collateral\r\n * 2. Reactive Network triggers executeLoop():\r\n *    - Borrow USDC from pool\r\n *    - \"Swap\" USDC → WETH (mint for demo)\r\n *    - Supply WETH back to pool\r\n *    - Repeat up to 5 times\r\n * 3. On price crash, Reactive Network triggers unwind():\r\n *    - \"Flash loan\" USDC (mint for demo)\r\n *    - Repay all debt\r\n *    - Withdraw all collateral\r\n */\r\ncontract ReactiveVault is IPayer {\r\n    // ============ Constants ============\r\n    \r\n    /// @notice Mock Lending Pool address\r\n    address public immutable POOL;\r\n    \r\n    /// @notice Reactive Network Callback Proxy on Sepolia\r\n    address public constant CALLBACK_PROXY = 0xc9f36411C9897e7F959D99ffca2a0Ba7ee0D7bDA;\r\n    \r\n    // ============ Immutable State ============\r\n    \r\n    /// @notice Authorized Reactive VM ID (deployer of ShieldBrain)\r\n    address public immutable reactiveVmId;\r\n    \r\n    /// @notice Collateral token (MockWETH)\r\n    IERC20 public immutable collateralToken;\r\n    \r\n    /// @notice Loan token (MockUSDC)\r\n    IERC20 public immutable loanToken;\r\n    \r\n    // ============ Strategy Parameters ============\r\n    \r\n    /// @notice Target Loan-to-Value ratio (70%)\r\n    uint256 public constant TARGET_LTV = 70;\r\n    \r\n    /// @notice Maximum loop iterations\r\n    uint8 public constant MAX_LOOPS = 5;\r\n    \r\n    /// @notice Loop iteration counter\r\n    uint8 public loopCount;\r\n    \r\n    // ============ Events ============\r\n    \r\n    event Deposit(address indexed user, uint256 amount);\r\n    event LoopStep(uint8 iteration, uint256 borrowedAmount, uint256 mintedCollateral);\r\n    event Unwind(uint256 repaidDebt, uint256 withdrawnCollateral);\r\n    \r\n    // ============ Errors ============\r\n    \r\n    error UnauthorizedCaller();\r\n    error TransferFailed();\r\n    error MaxLoopsReached();\r\n    error InvalidAmount();\r\n    \r\n    // ============ Constructor ============\r\n    \r\n    /**\r\n     * @notice Initialize the vault\r\n     * @param _pool MockLendingPool address\r\n     * @param _collateralToken MockWETH address\r\n     * @param _loanToken MockUSDC address\r\n     * @param _reactiveVmId Authorized Reactive VM ID (ShieldBrain deployer)\r\n     */\r\n    constructor(\r\n        address _pool,\r\n        address _collateralToken,\r\n        address _loanToken,\r\n        address _reactiveVmId\r\n    ) {\r\n        POOL = _pool;\r\n        collateralToken = IERC20(_collateralToken);\r\n        loanToken = IERC20(_loanToken);\r\n        reactiveVmId = _reactiveVmId;\r\n    }\r\n    \r\n    // ============ User Entry Point ============\r\n    \r\n    /**\r\n     * @notice Deposit collateral to start leveraged position\r\n     * @param amount Amount of WETH to deposit (18 decimals)\r\n     */\r\n    function deposit(uint256 amount) external {\r\n        if (amount == 0) revert InvalidAmount();\r\n        \r\n        // Reset loop counter for new deposit\r\n        loopCount = 0;\r\n        \r\n        // Transfer WETH from user to vault\r\n        bool success = collateralToken.transferFrom(msg.sender, address(this), amount);\r\n        if (!success) revert TransferFailed();\r\n        \r\n        // Approve pool to spend WETH\r\n        collateralToken.approve(POOL, amount);\r\n        \r\n        // Supply collateral to pool\r\n        ILendingPool(POOL).supply(\r\n            address(collateralToken),\r\n            amount,\r\n            address(this) // Supply on behalf of this vault\r\n        );\r\n        \r\n        // Emit event to trigger Reactive Network\r\n        emit Deposit(msg.sender, amount);\r\n    }\r\n    \r\n    // ============ Reactive Automation ============\r\n    \r\n    /**\r\n     * @notice Execute one leverage loop iteration\r\n     * @param sender RVM ID (injected by Reactive Network)\r\n     * \r\n     * Steps:\r\n     * 1. Borrow USDC from pool (against WETH collateral)\r\n     * 2. \"Swap\" USDC → WETH (mint for demo)\r\n     * 3. Supply new WETH as collateral\r\n     * 4. Emit LoopStep event\r\n     */\r\n    function executeLoop(address sender) external onlyReactive(sender) {\r\n        // Check if max loops reached\r\n        if (loopCount >= MAX_LOOPS) {\r\n            revert MaxLoopsReached();\r\n        }\r\n        \r\n        loopCount++;\r\n        \r\n        // Step 1: Check available borrow capacity\r\n        (, , uint256 availableBorrow, uint256 healthFactor) = ILendingPool(POOL).getUserAccountData(\r\n            address(this),\r\n            address(collateralToken),\r\n            address(loanToken)\r\n        );\r\n        \r\n        // Safety check: Don't borrow if health factor too low\r\n        if (healthFactor < 1200000000000000000) { // < 1.2\r\n            revert MaxLoopsReached(); // Use this to stop looping\r\n        }\r\n        \r\n        // Calculate safe borrow amount (80% of available)\r\n        uint256 borrowAmount = (availableBorrow * 80) / 100;\r\n        \r\n        // Minimum borrow check\r\n        if (borrowAmount < 100 * 1e6) { // Less than 100 USDC\r\n            revert MaxLoopsReached(); // Stop looping\r\n        }\r\n        \r\n        // Step 2: Borrow USDC from pool\r\n        ILendingPool(POOL).borrow(\r\n            address(collateralToken), // Collateral\r\n            address(loanToken),       // Borrow token\r\n            borrowAmount,             // Amount\r\n            address(this),            // Borrow on behalf of vault\r\n            address(this)             // Receive borrowed tokens\r\n        );\r\n        \r\n        // Step 3: \"Swap\" USDC → WETH (mint for demo)\r\n        // Assume price: 1 ETH = $3000\r\n        // borrowAmount is in USDC (6 decimals)\r\n        // wethAmount should be in WETH (18 decimals)\r\n        uint256 wethAmount = (borrowAmount * 1e18) / 3000e6;\r\n        \r\n        // Mint WETH to vault (simulates swap)\r\n        (bool mintSuccess, ) = address(collateralToken).call(\r\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), wethAmount)\r\n        );\r\n        require(mintSuccess, \"Mint failed\");\r\n        \r\n        // Step 4: Supply minted WETH back to pool\r\n        collateralToken.approve(POOL, wethAmount);\r\n        ILendingPool(POOL).supply(\r\n            address(collateralToken),\r\n            wethAmount,\r\n            address(this)\r\n        );\r\n        \r\n        // Emit event to trigger next iteration\r\n        emit LoopStep(loopCount, borrowAmount, wethAmount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency unwind: Close leveraged position\r\n     * @param sender RVM ID (injected by Reactive Network)\r\n     * \r\n     * Steps:\r\n     * 1. \"Flash loan\" USDC (mint for demo)\r\n     * 2. Repay all debt\r\n     * 3. Withdraw all collateral\r\n     */\r\n    function unwind(address sender) external onlyReactive(sender) {\r\n        // Get current position\r\n        (uint256 collateral, uint256 debt) = ILendingPool(POOL).getPosition(\r\n            address(this),\r\n            address(collateralToken),\r\n            address(loanToken)\r\n        );\r\n        \r\n        // If no debt, nothing to unwind\r\n        if (debt == 0) {\r\n            emit Unwind(0, collateral);\r\n            return;\r\n        }\r\n        \r\n        // Step 1: \"Flash loan\" USDC to repay debt (mint for demo)\r\n        // Add 10% buffer for safety\r\n        uint256 repayAmount = (debt * 110) / 100;\r\n        \r\n        (bool mintSuccess, ) = address(loanToken).call(\r\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), repayAmount)\r\n        );\r\n        require(mintSuccess, \"Mint failed\");\r\n        \r\n        // Step 2: Approve pool to spend USDC\r\n        loanToken.approve(POOL, repayAmount);\r\n        \r\n        // Step 3: Repay all debt\r\n        uint256 repaid = ILendingPool(POOL).repay(\r\n            address(loanToken),\r\n            type(uint256).max, // Repay all\r\n            address(this)\r\n        );\r\n        \r\n        // Step 4: Withdraw all collateral\r\n        uint256 withdrawn = ILendingPool(POOL).withdraw(\r\n            address(collateralToken),\r\n            type(uint256).max, // Withdraw all\r\n            address(this),\r\n            address(this)\r\n        );\r\n        \r\n        // Reset loop counter\r\n        loopCount = 0;\r\n        \r\n        emit Unwind(repaid, withdrawn);\r\n    }\r\n    \r\n    // ============ View Functions ============\r\n    \r\n    /**\r\n     * @notice Get current position status\r\n     * @return collateral Amount of collateral supplied\r\n     * @return debt Amount of debt\r\n     * @return currentLoopCount Current loop iteration\r\n     * @return healthFactor Current health factor\r\n     */\r\n    function getPosition()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 collateral,\r\n            uint256 debt,\r\n            uint8 currentLoopCount,\r\n            uint256 healthFactor\r\n        )\r\n    {\r\n        uint256 availableBorrow;\r\n        (collateral, debt, availableBorrow, healthFactor) = ILendingPool(POOL).getUserAccountData(\r\n            address(this),\r\n            address(collateralToken),\r\n            address(loanToken)\r\n        );\r\n        \r\n        return (collateral, debt, loopCount, healthFactor);\r\n    }\r\n    \r\n    // ============ Security ============\r\n    \r\n    /**\r\n     * @notice Modifier to ensure only Reactive Network can call\r\n     * @param sender RVM ID injected by Reactive Network\r\n     */\r\n    modifier onlyReactive(address sender) {\r\n        if (msg.sender != CALLBACK_PROXY) revert UnauthorizedCaller();\r\n        if (sender != reactiveVmId) revert UnauthorizedCaller();\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @notice Receive funding for callback gas\r\n     */\r\n    function pay() external payable override {\r\n        // Accepts ETH for callback execution gas\r\n    }\r\n    \r\n    /**\r\n     * @notice Allow contract to receive ETH\r\n     */\r\n    receive() external payable {}\r\n}\r\n\r\n"
      }
    }
  }
}