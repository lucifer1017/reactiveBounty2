{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-c21ddc5210717efa4f497ae05d8620408b202680",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ReactiveVault.sol": "project/contracts/ReactiveVault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/ILendingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title ILendingPool\r\n * @notice Interface for MockLendingPool\r\n */\r\ninterface ILendingPool {\r\n    /**\r\n     * @notice Supply collateral to the pool\r\n     * @param token Collateral token address\r\n     * @param amount Amount to supply\r\n     * @param onBehalf Address to supply on behalf of\r\n     */\r\n    function supply(address token, uint256 amount, address onBehalf) external;\r\n    \r\n    /**\r\n     * @notice Borrow tokens against collateral\r\n     * @param collateralToken Collateral token address\r\n     * @param borrowToken Token to borrow\r\n     * @param amount Amount to borrow\r\n     * @param onBehalf Address to borrow on behalf of\r\n     * @param receiver Address to receive borrowed tokens\r\n     */\r\n    function borrow(\r\n        address collateralToken,\r\n        address borrowToken,\r\n        uint256 amount,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external;\r\n    \r\n    /**\r\n     * @notice Repay borrowed tokens\r\n     * @param token Token to repay\r\n     * @param amount Amount to repay (use type(uint256).max for full repayment)\r\n     * @param onBehalf Address to repay debt for\r\n     * @return Amount actually repaid\r\n     */\r\n    function repay(address token, uint256 amount, address onBehalf) external returns (uint256);\r\n    \r\n    /**\r\n     * @notice Withdraw collateral from the pool\r\n     * @param token Collateral token address\r\n     * @param amount Amount to withdraw (use type(uint256).max for full withdrawal)\r\n     * @param onBehalf Address to withdraw collateral for\r\n     * @param receiver Address to receive withdrawn tokens\r\n     * @return Amount actually withdrawn\r\n     */\r\n    function withdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address onBehalf,\r\n        address receiver\r\n    ) external returns (uint256);\r\n    \r\n    /**\r\n     * @notice Get user account data\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return totalCollateral Total collateral\r\n     * @return totalDebt Total debt\r\n     * @return availableBorrow Available borrow capacity\r\n     * @return healthFactor Current health factor\r\n     */\r\n    function getUserAccountData(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) external view returns (\r\n        uint256 totalCollateral,\r\n        uint256 totalDebt,\r\n        uint256 availableBorrow,\r\n        uint256 healthFactor\r\n    );\r\n    \r\n    /**\r\n     * @notice Get user position\r\n     * @param user User address\r\n     * @param collateralToken Collateral token\r\n     * @param borrowToken Borrow token\r\n     * @return collateral User's collateral\r\n     * @return debt User's debt\r\n     */\r\n    function getPosition(\r\n        address user,\r\n        address collateralToken,\r\n        address borrowToken\r\n    ) external view returns (uint256 collateral, uint256 debt);\r\n    \r\n    /**\r\n     * @notice Seed liquidity (mint and add to pool)\r\n     * @param token Token to seed\r\n     * @param amount Amount to seed\r\n     */\r\n    function seedLiquidity(address token, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title IERC20\r\n * @notice Minimal ERC20 interface\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n"
      },
      "project/contracts/IReactive.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Standard Reactive Network interfaces and constants\n\nuint256 constant REACTIVE_IGNORE = 0xa65f96fc951c35ead38878e0f0b7a3c744a6f5ccc1476b313353ce31712313ad;\n\ninterface IPayer {\n    function pay() external payable;\n}\n\ninterface IReactive is IPayer {\n    /**\n     * @notice Event log structure from origin chain\n     * @dev 12-field LogRecord as per Reactive Network specification\n     */\n    struct LogRecord {\n        uint256 chain_id;\n        address _contract;\n        uint256 topic_0;\n        uint256 topic_1;\n        uint256 topic_2;\n        uint256 topic_3;\n        bytes data;\n        uint256 block_number;\n        uint256 op_code;\n        uint256 block_hash;\n        uint256 tx_hash;\n        uint256 log_index;\n    }\n\n    /**\n     * @notice Callback event to trigger cross-chain execution\n     * @param chain_id Destination chain ID\n     * @param _contract Target contract address\n     * @param gas_limit Gas limit for execution\n     * @param payload Encoded function call\n     */\n    event Callback(\n        uint256 indexed chain_id,\n        address indexed _contract,\n        uint64 indexed gas_limit,\n        bytes payload\n    );\n\n    /**\n     * @notice Main reactive function triggered by subscribed events\n     * @param log Event log data from origin chain\n     */\n    function react(LogRecord calldata log) external;\n}\n\ninterface ISystemContract {\n    /**\n     * @notice Subscribe to events on origin chain\n     * @param chain_id Origin chain ID\n     * @param contract_address Contract to monitor\n     * @param topic_0 Event signature\n     * @param topic_1 First indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_2 Second indexed parameter (or REACTIVE_IGNORE)\n     * @param topic_3 Third indexed parameter (or REACTIVE_IGNORE)\n     */\n    function subscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n\n    /**\n     * @notice Unsubscribe from events\n     */\n    function unsubscribe(\n        uint256 chain_id,\n        address contract_address,\n        uint256 topic_0,\n        uint256 topic_1,\n        uint256 topic_2,\n        uint256 topic_3\n    ) external;\n}\n\n"
      },
      "project/contracts/ReactiveVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IReactive.sol\";\nimport \"./interfaces/ILendingPool.sol\";\n\n/**\n * @title ReactiveVault\n * @notice Automated DeFi Looping Vault using MockLendingPool\n * @dev Simplified architecture with mock lending protocol\n * \n * Flow:\n * 1. User deposits WETH collateral\n * 2. Reactive Network triggers executeLoop():\n *    - Borrow USDC from pool\n *    - \"Swap\" USDC → WETH (mint for demo)\n *    - Supply WETH back to pool\n *    - Repeat up to 5 times\n * 3. On price crash, Reactive Network triggers unwind():\n *    - \"Flash loan\" USDC (mint for demo)\n *    - Repay all debt\n *    - Withdraw all collateral\n */\ncontract ReactiveVault is IPayer {\n    // ============ Constants ============\n    \n    /// @notice Mock Lending Pool address\n    address public immutable POOL;\n    \n    /// @notice Reactive Network Callback Proxy on Sepolia\n    address public constant CALLBACK_PROXY = 0xc9f36411C9897e7F959D99ffca2a0Ba7ee0D7bDA;\n    \n    // ============ Immutable State ============\n    \n    /// @notice Authorized Reactive VM ID (deployer of ShieldBrain)\n    address public immutable reactiveVmId;\n    \n    /// @notice Collateral token (MockWETH)\n    IERC20 public immutable collateralToken;\n    \n    /// @notice Loan token (MockUSDC)\n    IERC20 public immutable loanToken;\n    \n    // ============ Strategy Parameters ============\n    \n    /// @notice Target Loan-to-Value ratio (70%)\n    uint256 public constant TARGET_LTV = 70;\n    \n    /// @notice Maximum loop iterations\n    uint8 public constant MAX_LOOPS = 5;\n    \n    /// @notice Loop iteration counter\n    uint8 public loopCount;\n    \n    // ============ Events ============\n    \n    event Deposit(address indexed user, uint256 amount);\n    event LoopStep(uint8 iteration, uint256 borrowedAmount, uint256 mintedCollateral);\n    event Unwind(uint256 repaidDebt, uint256 withdrawnCollateral);\n    \n    // ============ Errors ============\n    \n    error UnauthorizedCaller();\n    error TransferFailed();\n    error MaxLoopsReached();\n    error InvalidAmount();\n    \n    // ============ Constructor ============\n    \n    /**\n     * @notice Initialize the vault\n     * @param _pool MockLendingPool address\n     * @param _collateralToken MockWETH address\n     * @param _loanToken MockUSDC address\n     * @param _reactiveVmId Authorized Reactive VM ID (ShieldBrain deployer)\n     */\n    constructor(\n        address _pool,\n        address _collateralToken,\n        address _loanToken,\n        address _reactiveVmId\n    ) {\n        POOL = _pool;\n        collateralToken = IERC20(_collateralToken);\n        loanToken = IERC20(_loanToken);\n        reactiveVmId = _reactiveVmId;\n    }\n    \n    // ============ User Entry Point ============\n    \n    /**\n     * @notice Deposit collateral to start leveraged position\n     * @param amount Amount of WETH to deposit (18 decimals)\n     */\n    function deposit(uint256 amount) external {\n        if (amount == 0) revert InvalidAmount();\n        \n        // Reset loop counter for new deposit\n        loopCount = 0;\n        \n        // Transfer WETH from user to vault\n        bool success = collateralToken.transferFrom(msg.sender, address(this), amount);\n        if (!success) revert TransferFailed();\n        \n        // Approve pool to spend WETH\n        collateralToken.approve(POOL, amount);\n        \n        // Supply collateral to pool\n        ILendingPool(POOL).supply(\n            address(collateralToken),\n            amount,\n            address(this) // Supply on behalf of this vault\n        );\n        \n        // Emit event to trigger Reactive Network\n        emit Deposit(msg.sender, amount);\n    }\n    \n    // ============ Reactive Automation ============\n    \n    /**\n     * @notice Execute one leverage loop iteration\n     * @param sender RVM ID (injected by Reactive Network)\n     * \n     * Steps:\n     * 1. Borrow USDC from pool (against WETH collateral)\n     * 2. \"Swap\" USDC → WETH (mint for demo)\n     * 3. Supply new WETH as collateral\n     * 4. Emit LoopStep event\n     */\n    function executeLoop(address sender) external onlyReactive(sender) {\n        // Check if max loops reached\n        if (loopCount >= MAX_LOOPS) {\n            revert MaxLoopsReached();\n        }\n        \n        loopCount++;\n        \n        // Step 1: Check available borrow capacity\n        (, , uint256 availableBorrow, uint256 healthFactor) = ILendingPool(POOL).getUserAccountData(\n            address(this),\n            address(collateralToken),\n            address(loanToken)\n        );\n        \n        // Safety check: Don't borrow if health factor too low\n        if (healthFactor < 1200000000000000000) { // < 1.2\n            revert MaxLoopsReached(); // Use this to stop looping\n        }\n        \n        // Calculate safe borrow amount (30% of available)\n        // Using 30% to ensure health factor stays > 1.2 after borrow\n        // This allows all 5 loops to complete successfully\n        uint256 borrowAmount = (availableBorrow * 30) / 100;\n        \n        // Minimum borrow check\n        if (borrowAmount < 50 * 1e6) { // Less than 50 USDC\n            revert MaxLoopsReached(); // Stop looping\n        }\n        \n        // Step 2: Borrow USDC from pool\n        ILendingPool(POOL).borrow(\n            address(collateralToken), // Collateral\n            address(loanToken),       // Borrow token\n            borrowAmount,             // Amount\n            address(this),            // Borrow on behalf of vault\n            address(this)             // Receive borrowed tokens\n        );\n        \n        // Step 3: \"Swap\" USDC → WETH (mint for demo)\n        // Assume price: 1 ETH = $3000\n        // borrowAmount is in USDC (6 decimals)\n        // wethAmount should be in WETH (18 decimals)\n        uint256 wethAmount = (borrowAmount * 1e18) / 3000e6;\n        \n        // Mint WETH to vault (simulates swap)\n        (bool mintSuccess, ) = address(collateralToken).call(\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), wethAmount)\n        );\n        require(mintSuccess, \"Mint failed\");\n        \n        // Step 4: Supply minted WETH back to pool\n        collateralToken.approve(POOL, wethAmount);\n        ILendingPool(POOL).supply(\n            address(collateralToken),\n            wethAmount,\n            address(this)\n        );\n        \n        // Emit event to trigger next iteration\n        emit LoopStep(loopCount, borrowAmount, wethAmount);\n    }\n    \n    /**\n     * @notice Emergency unwind: Close leveraged position\n     * @param sender RVM ID (injected by Reactive Network)\n     * \n     * Steps:\n     * 1. \"Flash loan\" USDC (mint for demo)\n     * 2. Repay all debt\n     * 3. Withdraw all collateral\n     */\n    function unwind(address sender) external onlyReactive(sender) {\n        // Get current position\n        (uint256 collateral, uint256 debt) = ILendingPool(POOL).getPosition(\n            address(this),\n            address(collateralToken),\n            address(loanToken)\n        );\n        \n        // If no debt, nothing to unwind\n        if (debt == 0) {\n            emit Unwind(0, collateral);\n            return;\n        }\n        \n        // Step 1: \"Flash loan\" USDC to repay debt (mint for demo)\n        // Add 10% buffer for safety\n        uint256 repayAmount = (debt * 110) / 100;\n        \n        (bool mintSuccess, ) = address(loanToken).call(\n            abi.encodeWithSignature(\"mint(address,uint256)\", address(this), repayAmount)\n        );\n        require(mintSuccess, \"Mint failed\");\n        \n        // Step 2: Approve pool to spend USDC\n        loanToken.approve(POOL, repayAmount);\n        \n        // Step 3: Repay all debt\n        uint256 repaid = ILendingPool(POOL).repay(\n            address(loanToken),\n            type(uint256).max, // Repay all\n            address(this)\n        );\n        \n        // Step 4: Withdraw all collateral\n        uint256 withdrawn = ILendingPool(POOL).withdraw(\n            address(collateralToken),\n            type(uint256).max, // Withdraw all\n            address(this),\n            address(this)\n        );\n        \n        // Reset loop counter\n        loopCount = 0;\n        \n        emit Unwind(repaid, withdrawn);\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Get current position status\n     * @return collateral Amount of collateral supplied\n     * @return debt Amount of debt\n     * @return currentLoopCount Current loop iteration\n     * @return healthFactor Current health factor\n     */\n    function getPosition()\n        external\n        view\n        returns (\n            uint256 collateral,\n            uint256 debt,\n            uint8 currentLoopCount,\n            uint256 healthFactor\n        )\n    {\n        uint256 availableBorrow;\n        (collateral, debt, availableBorrow, healthFactor) = ILendingPool(POOL).getUserAccountData(\n            address(this),\n            address(collateralToken),\n            address(loanToken)\n        );\n        \n        return (collateral, debt, loopCount, healthFactor);\n    }\n    \n    // ============ Security ============\n    \n    /**\n     * @notice Modifier to ensure only Reactive Network Callback Proxy can call\n     * @param sender RVM ID injected by Reactive Network (unused, kept for interface compatibility)\n     */\n    modifier onlyReactive(address sender) {\n        (sender); // Silence unused parameter warning\n        if (msg.sender != CALLBACK_PROXY) revert UnauthorizedCaller();\n        _;\n    }\n    \n    /**\n     * @notice Receive funding for callback gas\n     */\n    function pay() external payable override {\n        // Accepts ETH for callback execution gas\n    }\n    \n    /**\n     * @notice Allow contract to receive ETH\n     */\n    receive() external payable {}\n}\n\n"
      }
    }
  }
}